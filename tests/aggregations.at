dnl Test suite containing tests that don't fit another file
AT_BANNER([------------------  AGGREGATION TESTS -----------------------])

dnl Here we try to change the values of an existing variable, which is disallowed in this version
AT_ASSERT_PARSE_ERROR([agg/error_multi_aggs.ncml])
AT_ASSERT_PARSE_ERROR([agg/error_improper_netcdf_loc.ncml])
AT_ASSERT_PARSE_ERROR([agg/error_agg_in_wrong_loc_1.ncml])
AT_ASSERT_PARSE_ERROR([agg/error_agg_in_wrong_loc_2.ncml])

dnl UNION : Acceptance tests on attributes and variables for union
dnl First, test a basic purely virtual dataset one level deep aggregates correctly.
AT_CHECK_ALL_DAP_RESPONSES([agg/virtual_union.ncml])
AT_CHECK_DATADDS_GETDAP([agg/virtual_union.ncml])

dnl TODO test a two level nest to make sure that works correctly
AT_CHECK_ALL_DAP_RESPONSES([agg/multi_nested_unions.ncml])
AT_CHECK_DATADDS_GETDAP([agg/multi_nested_unions.ncml])

dnl TODO test that NcML transformations can be applied to data AFTER
dnl it has been aggregated.  
AT_CHECK_ALL_DAP_RESPONSES([agg/modify_post_union.ncml])
AT_CHECK_DATADDS_GETDAP([agg/modify_post_union.ncml])

dnl Test from the Unidata NCML Aggregation tutorial
AT_CHECK_ALL_DAP_RESPONSES([agg/aggUnionSimple.ncml])

dnl----------------- Dimensions ---------------------------
dnl Test example virtual datasets with dimensions.

dnl Check that a union with correct matching dimensions works
dnl Technically, there's nothing to check since the dims are used 
dnl inside the child datasets to generate data, and not otherwise...
dnl Only shared would technically need to match, but DAP2 doesn't have them yet...
AT_CHECK_ALL_DAP_RESPONSES([agg/union_with_dimensions.ncml])
AT_CHECK_DATADDS_GETDAP([agg/union_with_dimensions.ncml])

dnl Check parse error on a dimension mismatch in the union
dnl This is where we'd have to make the error...  We're not
dnl going to traverse into DAP objects to check dimensions for now...
AT_ASSERT_PARSE_ERROR([agg/union_dimension_mismatch_error.ncml])

dnl ------------ joinNew -----------------

dnl Test the parse error branches
dnl Test that not having an aggregation variable in all datasets is an error
AT_ASSERT_PARSE_ERROR([agg/joinNew_error_1.ncml])
dnl Test that datasets not all matching type is an error
AT_ASSERT_PARSE_ERROR([agg/joinNew_error_2.ncml])
dnl Test datasets not matching shapes is an error
AT_ASSERT_PARSE_ERROR([agg/joinNew_error_3.ncml])
dnl Test datasets not matching dimension length is error
AT_ASSERT_PARSE_ERROR([agg/joinNew_error_4.ncml])

dnl Tests for simple joinNew aggregation 
AT_CHECK_ALL_DAP_RESPONSES([agg/joinNew_simple.ncml])
AT_CHECK_DATADDS_GETDAP([agg/joinNew_simple.ncml])

dnl Another example with more datasets
AT_CHECK_ALL_DAP_RESPONSES([agg/joinNew_simple_2.ncml])
AT_CHECK_DATADDS_GETDAP([agg/joinNew_simple_2.ncml])

dnl Another with more than one aggregation variable
AT_CHECK_ALL_DAP_RESPONSES([agg/joinNew_simple_3.ncml])
AT_CHECK_DATADDS_GETDAP([agg/joinNew_simple_3.ncml])

dnl =======================================================
dnl Test constraints on the virtual dataset aggs

dnl Test that the outer dimension slices match the original datasets
AT_CHECK_ALL_DAP_RESPONSES_WITH_CONSTRAINT([agg/joinNew_simple.ncml],[[ V[0][0:4] ]], [agg/joinNew_simple_cons_1.ncml])
AT_CHECK_ALL_DAP_RESPONSES_WITH_CONSTRAINT([agg/joinNew_simple.ncml],[[ V[1][0:4] ]], [agg/joinNew_simple_cons_2.ncml])

dnl Test grabbing a slice from the "middle" of an aggregated set
AT_CHECK_ALL_DAP_RESPONSES_WITH_CONSTRAINT([agg/joinNew_simple_2.ncml],[[ V[2][1:2] ]], [agg/joinNew_simple_2_cons_1.ncml])

dnl Grab two separate dataset slices from the middle
AT_CHECK_ALL_DAP_RESPONSES_WITH_CONSTRAINT([agg/joinNew_simple_2.ncml],[[ V[1:2][0:4] ]], [agg/joinNew_simple_2_cons_2.ncml])

dnl Grab an outside dimension slice of just one entry (second entry of all datasets)
AT_CHECK_ALL_DAP_RESPONSES_WITH_CONSTRAINT([agg/joinNew_simple_2.ncml],[[ V[0:3][1] ]], [agg/joinNew_simple_2_cons_3.ncml])

dnl Test a Netcdf Array aggregation, in this case three fnoc1.nc appended together as a joinNew
AT_CHECK_ALL_DAP_RESPONSES([agg/netcdf_joinNew.ncml])
AT_CHECK_ALL_DAP_RESPONSES_WITH_CONSTRAINT([agg/netcdf_joinNew.ncml],[[ u[1][0][10:11][10:11] ]], [agg/netcdf_joinNew_cons_1.ncml])

dnl Test with HDF5 Datasets
AT_CHECK_ALL_DAP_RESPONSES([agg/joinNew_hdf5.ncml])

dnl Test adding an explicit map vector after the array aggregation that
dnl refers to the new outer dimension.  Has metadata and explicit
dnl values list.
AT_CHECK_ALL_DAP_RESPONSES([agg/joinNew_with_explicit_map.ncml])
AT_CHECK_DATADDS_GETDAP([agg/joinNew_with_explicit_map.ncml])

dnl Also test we can set an explicit map with autogenerated 
dnl values via the values@start and values@increment form of values element
dnl if defined AFTER the aggregation in the file.
AT_CHECK_ALL_DAP_RESPONSES([agg/joinNew_explicit_autogen.ncml])
AT_CHECK_DATADDS_GETDAP([agg/joinNew_explicit_autogen.ncml])

dnl Make sure that the wrong number of entries in the explicit map
dnl is an error.
AT_ASSERT_PARSE_ERROR([agg/joinNew_explicit_map_err_1.ncml])

dnl Make sure that a coord var of form name(!name) is an error.
dnl Coordinate variables must have the same name and single dimension
dnl of the new outer dimension for the joinNew!
AT_ASSERT_PARSE_ERROR([agg/joinNew_explicit_map_err_2.ncml])

dnl Test the use of coordValue on all explicitly listed datasets 
dnl produces a proper coordinate variable.  
dnl Note there are two cases:
dnl     o Numeric coords
dnl     o String coords (all else)

dnl String 
AT_CHECK_ALL_DAP_RESPONSES([agg/joinNew_string_coordVal.ncml])
AT_CHECK_DATADDS_GETDAP([agg/joinNew_string_coordVal.ncml])

dnl Numeric
AT_CHECK_ALL_DAP_RESPONSES([agg/joinNew_numeric_coordValue.ncml])
AT_CHECK_DATADDS_GETDAP([agg/joinNew_numeric_coordValue.ncml])

dnl Rejection tests (parse error) for coordValue are needed as well for cases:
dnl 	o First netcdf has numeric, but a later one doesn't.
dnl     o First netcdf has string, but a later one has empty string.
AT_ASSERT_PARSE_ERROR([agg/joinNew_string_coordVal_error.ncml])
dnl Check for a missing number after first
AT_ASSERT_PARSE_ERROR([agg/joinNew_numeric_coordValue_error_1.ncml])
dnl Check for a malformed number after first
AT_ASSERT_PARSE_ERROR([agg/joinNew_numeric_coordValue_error_2.ncml])

dnl TODO support for Grid and coordValue for the new map vector.

dnl --------------------------------------------------------------------------
dnl Test joinNew on Grid data.

dnl TODO Add test for a full aggregation?  Not sure anyone would ever
dnl do this in practice, but it would be good for us to know.

dnl Test constraints by choosing outer dimension slice for
dnl each set in the aggregation, each of which also has
dnl a slice taken from it.  

dnl ----------- TODO FIX THESE  These cause a problem with the attributes coming from the first dataset in 
dnl ------------ aggregation, but not in constrained outer dim....  Once we know right answer, we move on.
AT_CHECK_ALL_DAP_RESPONSES_WITH_CONSTRAINT([agg/joinNew_grid.ncml],[[ dsp_band_1[0][512][0:1023] ]], [agg/joinNew_grid_hslab_0])
dnl AT_CHECK_ALL_DAP_RESPONSES_WITH_CONSTRAINT([agg/joinNew_grid.ncml],[[ dsp_band_1[1][512][0:1023] ]], [agg/joinNew_grid_hslab_1])
dnl AT_CHECK_ALL_DAP_RESPONSES_WITH_CONSTRAINT([agg/joinNew_grid.ncml],[[ dsp_band_1[2][512][0:1023] ]], [agg/joinNew_grid_hslab_2])
dnl AT_CHECK_ALL_DAP_RESPONSES_WITH_CONSTRAINT([agg/joinNew_grid.ncml],[[ dsp_band_1[3][512][0:1023] ]], [agg/joinNew_grid_hslab_3])
AT_RUN_BES_AND_COMPARE([agg/joinNew_grid.ncml],[dods],[agg/joinNew_grid_hslab_1],[[ dsp_band_1[1][512][0:1023] ]])
AT_RUN_BES_AND_COMPARE([agg/joinNew_grid.ncml],[dods],[agg/joinNew_grid_hslab_2],[[ dsp_band_1[2][512][0:1023] ]])
AT_RUN_BES_AND_COMPARE([agg/joinNew_grid.ncml],[dods],[agg/joinNew_grid_hslab_3],[[ dsp_band_1[3][512][0:1023] ]])

dnl Testing that we can use a stride on the new dimension.
dnl getdap of the dods was compared with a handmade version
dnl from the original dataset getdaps (these are checked in
dnl also with a "handmade" extension for checking if needed).
AT_CHECK_ALL_DAP_RESPONSES_WITH_CONSTRAINT([agg/joinNew_grid.ncml],[[ dsp_band_1[0:2:3][512][0:1023] ]], [agg/joinNew_grid_stride_evens])
dnl TODO FIX ME Next one same issue with failure on metadata being from wrong spot...
dnl AT_CHECK_ALL_DAP_RESPONSES_WITH_CONSTRAINT([agg/joinNew_grid.ncml],[[ dsp_band_1[1:2:3][512][0:1023] ]],0 [agg/joinNew_grid_stride_odds])
AT_RUN_BES_AND_COMPARE([agg/joinNew_grid.ncml],[dods],[agg/joinNew_grid_stride_odds],[[ dsp_band_1[1:2:3][512][0:1023] ]])

dnl Test a projection of a map.  Internally this doesn't load any of the grid array's....
AT_CHECK_ALL_DAP_RESPONSES_WITH_CONSTRAINT([agg/joinNew_grid.ncml],[[ dsp_band_1.lat[0:63] ]], [agg/joinNew_grid_proj_lat])

dnl Test the scan element for joinNew.  Since we expect the same aggregation as joinNew_grid.ncml to be
dnl created by joinNew_scan.ncml, we simply use the old baselines but change the filename internally by hand.
AT_CHECK_ALL_DAP_RESPONSES_WITH_CONSTRAINT([agg/joinNew_scan.ncml],[[ dsp_band_1[0][512][0:1023] ]], [agg/joinNew_scan_hslab_0])
AT_RUN_BES_AND_COMPARE([agg/joinNew_scan.ncml],[dods],[agg/joinNew_scan_hslab_1],[[ dsp_band_1[1][512][0:1023] ]])
AT_RUN_BES_AND_COMPARE([agg/joinNew_scan.ncml],[dods],[agg/joinNew_scan_hslab_2],[[ dsp_band_1[2][512][0:1023] ]])
AT_RUN_BES_AND_COMPARE([agg/joinNew_scan.ncml],[dods],[agg/joinNew_scan_hslab_3],[[ dsp_band_1[3][512][0:1023] ]])

dnl Test some errors on improper <scan> use
dnl Make sure parse error if scan is not a child of aggregation only
AT_ASSERT_PARSE_ERROR([agg/joinNew_scan_error.ncml])

dnl Make sure error if the path location is spelled wrong (missing dir) 
AT_ASSERT_PARSE_ERROR([agg/joinNew_scan_dir_error.ncml])

dnl Test the scan with a regular expression that matches the same set of files
AT_CHECK_ALL_DAP_RESPONSES_WITH_CONSTRAINT([agg/joinNew_scan_regexp_1.ncml],[[ dsp_band_1[0][512][0:1023] ]], [agg/joinNew_scan_regexp_hslab_0])
AT_RUN_BES_AND_COMPARE([agg/joinNew_scan_regexp_1.ncml],[dods],[agg/joinNew_scan_regexp_hslab_1],[[ dsp_band_1[1][512][0:1023] ]])
AT_RUN_BES_AND_COMPARE([agg/joinNew_scan_regexp_1.ncml],[dods],[agg/joinNew_scan_regexp_hslab_2],[[ dsp_band_1[2][512][0:1023] ]])
AT_RUN_BES_AND_COMPARE([agg/joinNew_scan_regexp_1.ncml],[dods],[agg/joinNew_scan_regexp_hslab_3],[[ dsp_band_1[3][512][0:1023] ]])

AT_RUN_BES_AND_COMPARE([agg/joinNew_scan_regexp_2.ncml],[dods],[agg/joinNew_scan_regexp_2_hslab_0],[[ dsp_band_1[0][512][0:1023] ]])
AT_RUN_BES_AND_COMPARE([agg/joinNew_scan_regexp_2.ncml],[dods],[agg/joinNew_scan_regexp_2_hslab_1],[[ dsp_band_1[1][512][0:1023] ]])
AT_RUN_BES_AND_COMPARE([agg/joinNew_scan_regexp_2.ncml],[dods],[agg/joinNew_scan_regexp_2_hslab_2],[[ dsp_band_1[2][512][0:1023] ]])
AT_RUN_BES_AND_COMPARE([agg/joinNew_scan_regexp_2.ncml],[dods],[agg/joinNew_scan_regexp_2_hslab_3],[[ dsp_band_1[3][512][0:1023] ]])

dnl Make sure a malformed regexp throws a parse error with the regerror msg in it.
AT_ASSERT_PARSE_ERROR([agg/joinNew_scan_regexp_error_1.ncml])

dnl Tests scan@olderThan attribute for excluding new files
dnl First test a simple parse error if the value can't be parsed into a time.
AT_ASSERT_PARSE_ERROR([agg/joinNew_scan_olderThan_error_1.ncml])

dnl Next, we'll touch the first three grid files to make their mod time now,
dnl then do the scan and make sure we just get the data from the final grid...
dnl AT_CHECK([besstandalone -c bes_conf_path -i ./test.bescmd], [], [stdout], [ignore])
AT_SETUP([Invoking touch on first three grid files for scan@olderThan test...])
AT_CHECK([touch full_data_path/agg/grids/f97182070958.hdf],[ignore],[ignore],[ignore])
AT_CHECK([touch full_data_path/agg/grids/f97182183448.hdf],[ignore],[ignore],[ignore])
AT_CHECK([touch full_data_path/agg/grids/f97183065853.hdf],[ignore],[ignore],[ignore])
AT_CLEANUP
AT_RUN_BES_AND_COMPARE([agg/joinNew_scan_olderThan.ncml],[dods],[agg/joinNew_scan_olderThan_hslab],[[ dsp_band_1[0][512][0:1023] ]])

dnl Test the scan@dateFormatMark using the datasets and example from: 
dnl http://www.unidata.ucar.edu/software/netcdf/ncml/v2.2/Aggregation.html
AT_CHECK_ALL_DAP_RESPONSES([agg/joinNew_scan_dfm.ncml])
AT_CHECK_DATADDS_GETDAP([agg/joinNew_scan_dfm.ncml])

dnl Test that scan@dateFormatMark will properly sort on the ISO 8601
dnl coordValue and NOT filename if a dataFormatMark is specified.
dnl We do this with an aggregation whose lexicographic filename 
dnl sort is not chronological.
AT_CHECK_ALL_DAP_RESPONSES([agg/joinNew_scan_dfm_2.ncml])
AT_CHECK_DATADDS_GETDAP([agg/joinNew_scan_dfm_2.ncml])

dnl TODO Check that a malformed SimpleDateFormat is an error.
AT_ASSERT_PARSE_ERROR([agg/joinNew_scan_dfm_err_2.ncml])

dnl --------------------------------------------------
dnl ----- Placeholder variable metadata checks -----------
dnl Test adding metadata to the newly created coordinate value/map vectors in a Grid joinNew

dnl First, we add the metadata after the aggregation
AT_CHECK_ALL_DAP_RESPONSES([agg/joinNew_grid_metadata.ncml])

dnl And before the agg, both should work for placeholder data that is NOT explicit.
AT_CHECK_ALL_DAP_RESPONSES([agg/joinNew_grid_pre_metadata.ncml])

dnl Also, if the coordValue is numeric, the map can be a placeholder of type double
AT_CHECK_ALL_DAP_RESPONSES([agg/joinNew_grid_meta_2.ncml])

dnl --------------------------------------------------
dnl ----- joinNew Grid Metadata Rejection Tests

dnl Placeholder type does not match autogenerated type
AT_ASSERT_PARSE_ERROR([agg/joinNew_grid_meta_err_1.ncml])


