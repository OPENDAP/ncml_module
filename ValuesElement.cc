//////////////////////////////////////////////////////////////////////////////
// This file is part of the "NcML Module" project, a BES module designed
// to allow NcML files to be used to be used as a wrapper to add
// AIS to existing datasets of any format.
//
// Copyright (c) 2009 OPeNDAP, Inc.
// Author: Michael Johnson  <m.johnson@opendap.org>
//
// For more information, please also see the main website: http://opendap.org/
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// Please see the files COPYING and COPYRIGHT for more information on the GLPL.
//
// You can contact OPeNDAP, Inc. at PO Box 112, Saunderstown, RI. 02874-0112.
/////////////////////////////////////////////////////////////////////////////

#include "ValuesElement.h"

#include "BaseType.h"
#include "Array.h"
#include "Byte.h"
#include "Float32.h"
#include "Float64.h"
#include "Grid.h"
#include "Int16.h"
#include "Int32.h"
#include "Sequence.h"
#include "Str.h"
#include "Structure.h"
#include "UInt16.h"
#include "UInt32.h"
#include "Url.h"

#include "NCMLDebug.h"
#include "NCMLParser.h"
#include "NCMLUtil.h"
#include <sstream>
#include "VariableElement.h"

using namespace libdap;

namespace ncml_module
{
  const string ValuesElement::_sTypeName = "values";

  ValuesElement::ValuesElement()
  : _start("")
  , _increment("")
  , _separator(NCMLUtil::WHITESPACE)
  , _gotContent(false)
  , _tokens()
  {
    _tokens.reserve(256);
  }

  ValuesElement::ValuesElement(const ValuesElement& proto)
  : NCMLElement(proto)
  {
    _start = proto._start;
    _increment = proto._increment;
    _separator = proto._separator;

    // We don't really care about the ephemeral state of _tokens or _gotContent in a copy....
  }

  ValuesElement::~ValuesElement()
  {
    _tokens.resize(0);
  }

  const string&
  ValuesElement::getTypeName() const
  {
    return _sTypeName;
  }

  ValuesElement*
  ValuesElement::clone() const
  {
    return new ValuesElement(*this);
  }

  void
  ValuesElement::setAttributes(const AttributeMap& attrs)
  {
    _start = NCMLUtil::findAttrValue(attrs, "start");
    _increment = NCMLUtil::findAttrValue(attrs, "increment");
    _separator = NCMLUtil::findAttrValue(attrs, "separator", NCMLUtil::WHITESPACE);

    // Validate them... if _start is specified, then _increment must be as well!
    if (!_start.empty() && _increment.empty())
      {
        THROW_NCML_PARSE_ERROR("values element=" + toString() + " had a start attribute without a corresponding increment attribute!");
      }
    if (_start.empty() && !_increment.empty())
      {
        THROW_NCML_PARSE_ERROR("values element=" + toString() + " had an increment attribute without a corresponding start attribute!");
      }
  }

  void
  ValuesElement::handleBegin(NCMLParser& p)
  {
    BESDEBUG("ncml", "ValuesElement::handleBegin called with element=" << toString() << " at scope=" << p.getScopeString() << endl);

    // First, make sure we're in a current parse start for this elemnent
    if (!p.isScopeVariable())
      {
        THROW_NCML_PARSE_ERROR("Got values element while not parsing a variable!  values=" + toString() + " at scope=" + p.getTypedScopeString());
      }

    // OK, we're in a variable, that's good.  Nothing else to do since the content
    // will contain the actual variables!

    // If we got a start and increment, we are supposed to auto-generate values for the variable
    if (shouldAutoGenerateValues())
      {
        BaseType* pVar = p.getCurrentVariable();
        NCML_ASSERT_MSG(pVar, "ValuesElement::handleBegin(): Expected non-null p.getCurrentVariable()!");
        autogenerateAndSetVariableValues(p, *pVar);
      }
    // else we'll expect content
  }

  void
  ValuesElement::handleContent(NCMLParser& p, const string& content)
  {
    BESDEBUG("ncml", "ValuesElement::handleContent called for " << toString() << " with content=" << content << endl);

    // N.B. Technically, we're still in isScopeVariable() since we don't push values elements on the scopestack,
    // only the XML parser stack...

    // Make sure we don't get non-whitespace content for autogenerated values!
    if (shouldAutoGenerateValues() && !NCMLUtil::isAllWhitespace(content))
      {
        THROW_NCML_PARSE_ERROR("Element: " + toString() + " specified a start and increment to autogenerate values but also illegally specified content!");
      }

    // There had better be one or we goofed!
    BaseType* pVar = p.getCurrentVariable();
    NCML_ASSERT_MSG(pVar, "ValuesElement::handleContent: got unexpected null getCurrentVariable() from parser!!");

    // Tokenize the values for all cases EXCEPT if it's a scalar string.
    // We'll make a special exception an assume the entire content is the token
    // to avoid accidental tokenization with whitespace, which is clearly not intended
    // by the NcML file author!
    if (pVar->is_simple_type() &&
        (pVar->type() == dods_str_c || pVar->type() == dods_url_c))
      {
        _tokens.resize(0);
        _tokens.push_back(content);
      }
    else
      {
        NCMLUtil::tokenize(content, _tokens, _separator);
      }
    setVariableValuesFromTokens(p, *pVar);
  }

  void
  ValuesElement::handleEnd(NCMLParser& /* p */)
  {
    BESDEBUG("ncml", "ValuesElement::handleEnd called for " << toString() << endl);

    if (!shouldAutoGenerateValues() && !_gotContent)
      {
        THROW_NCML_PARSE_ERROR("Values element=" + toString() + " expected content for values but didn't get any!");
      }

    // Otherwise, we're all good.
  }

  string
  ValuesElement::toString() const
  {
    return "<" +_sTypeName + " " +
               ((_start.empty())?(""):("start=\"" + _start + "\" ")) +
               ((_increment.empty())?(""):("increment=\"" + _increment + "\" ")) +
               ((_separator == NCMLUtil::WHITESPACE)?(""):("separator=\"" + _separator + "\" ")) +
           ">";
  }

  void
  ValuesElement::validateStartAndIncrementForVariableTypeOrThrow(libdap::BaseType& /* pVar */) const
  {
    // TODO IMPL ME
    // Look up the types...
  }

  template <class DAPType, typename ValueType>
  void
  ValuesElement::setScalarValue(libdap::BaseType& var, const string& valueAsToken)
  {
    // Make sure we got the right subclass type
    DAPType* pVar = dynamic_cast<DAPType*>(&var);
    NCML_ASSERT_MSG(pVar, "setScalarValue() got called with BaseType not matching the expected type.");

    // Parse the token using stringstream and the template ValueType.
    std::stringstream sis;
    sis.str(valueAsToken);
    ValueType value;
    sis >> value;

    // assuming it works, there should be a setValue(ValueType) on pVar now
    pVar->set_value(value);
  }

 /** We need to specialize for the case of a Byte since the
  * stringstream >> will just read a single char and not assume the
  * string is a decimal value in [0, 255].
  */
  template <>
  void
  ValuesElement::setScalarValue<Byte, dods_byte>(libdap::BaseType& var, const string& valueAsToken)
  {
    Byte* pVar = dynamic_cast<Byte*>(&var);
    NCML_ASSERT_MSG(pVar, "setScalarValue() got called with BaseType not matching the expected type.");

    std::stringstream sis;
    sis.str(valueAsToken);
    dods_uint16 value; // read it as an unsigned short.
    sis >> value;

    // then cast it for the set...
    pVar->set_value(static_cast<dods_byte>(value));
  }

  /** We need to specialize for the case of a ValueType of std::string as well since the
   * stringstream >> will just read a single TOKEN and not the whole string.  Grr.
   */
   template <>
   void
   ValuesElement::setScalarValue<Str, string>(libdap::BaseType& var, const string& valueAsToken)
   {
     Str* pVar = dynamic_cast<Str*>(&var);
     NCML_ASSERT_MSG(pVar, "setScalarValue() got called with BaseType not matching the expected type.");
     pVar->set_value(valueAsToken);
   }


   /** We need to specialize for the case of a ValueType of std::string as well since the
    * stringstream >> will just read a single TOKEN and not the whole string.  Grr.
    */
   template <>
   void
   ValuesElement::setScalarValue<Url, string>(libdap::BaseType& var, const string& valueAsToken)
   {
     Url* pVar = dynamic_cast<Url*>(&var);
     NCML_ASSERT_MSG(pVar, "setScalarValue() got called with BaseType not matching the expected type.");
     pVar->set_value(valueAsToken);
   }

   /**
    * Special case call for parsing char since underlying type is same as byte but want to parse differently.
    */
   void
   ValuesElement::parseAndSetCharValue(libdap::BaseType& var, const string& valueAsToken)
   {
     Byte* pVar = dynamic_cast<Byte*>(&var);
     NCML_ASSERT_MSG(pVar, "setScalarValue() got called with BaseType not matching the expected type.");

     std::stringstream sis;
     sis.str(valueAsToken);
     unsigned char value; // read it as a char
     sis >> value;

     // then cast it for the set...
     pVar->set_value(static_cast<dods_byte>(value));
   }

  void
  ValuesElement::setVariableValuesFromTokens(NCMLParser& p, libdap::BaseType& var)
  {
    // It's an error to have <values> for a Structure variable!
    if (var.type() == dods_structure_c)
      {
        THROW_NCML_PARSE_ERROR("Illegal to specify <values> element for a Structure type variable name=" + var.name() +
            " at scope=" + p.getScopeString());
      }
    // First, make sure the dimensionality matches or we're doomed from the get-go
    if (!var.is_simple_type()) // we only handle scalars now!!
      {
        THROW_NCML_PARSE_ERROR("Unsupported: we're sorry only scalar variables may be added at this time"
            "but we got a vector variable type for variable name=" + var.name() + " at scope=" + p.getScopeString());
      }

    // OK, we have a scalar, so make sure there's exactly one token!
    if (_tokens.size() != 1)
      {
        stringstream msg;
        msg << "While setting scalar variable name=" << var.name() <<
               " we expected exactly 1 value in content but found " << _tokens.size() <<
               " tokens.";
        THROW_NCML_PARSE_ERROR(msg.str());
      }

    // OK, we have one token for a scalar.  Now make sure it's a valid value for the given type.
    // legacy "char" type (internally a byte) is specified differently, so don't check for that case.
    if (getNCMLTypeForVariable(p) != "char")
      {
        p.checkDataIsValidForCanonicalTypeOrThrow(var.type_name(), _tokens);
      }

    // Just one of em
    const string& valueToken = _tokens.at(0);

    // OK, now it gets pretty ugly, but we hid most of it behind a template...
    Type varType = var.type();
    switch (varType)
    {
      case dods_byte_c:
        // Special case depending on whether the underlying NcML was type-converted
        // from "char" or not
        if (getNCMLTypeForVariable(p) == "char")
          {
            parseAndSetCharValue(var, valueToken);
          }
        else
          {
            setScalarValue <Byte, dods_byte> (var, valueToken);
          }
        break;

      case dods_int16_c:
        setScalarValue<Int16, dods_int16>(var, valueToken);
        break;

      case dods_uint16_c:
        setScalarValue<UInt16, dods_uint16>(var, valueToken);
        break;

      case dods_int32_c:
        setScalarValue<Int32, dods_int32>(var, valueToken);
        break;

      case dods_uint32_c:
        setScalarValue<UInt32, dods_uint32>(var, valueToken);
        break;

      case dods_float32_c:
        setScalarValue<Float32, dods_float32>(var, valueToken);
        break;

      case dods_float64_c:
        setScalarValue<Float64, dods_float64>(var, valueToken);
        break;

      case dods_str_c:
        setScalarValue<Str, string>(var, valueToken);
        break;

      case dods_url_c:
        setScalarValue<Url, string>(var, valueToken);
        break;

      default:
        THROW_NCML_INTERNAL_ERROR("Expected simple type but didn't find it!");
        break;
    }
  }

  void
  ValuesElement::autogenerateAndSetVariableValues(NCMLParser& /* p */, BaseType& /* var */)
  {
    // TODO IMPL ME
    THROW_NCML_INTERNAL_ERROR("UNIMPLEMENTED METHOD: ValuesElement::autogenerateAndSetVariableValues:"
        " values@start and values@increment may not be used until this method is implemented!");

  }

  std::string
  ValuesElement::getNCMLTypeForVariable(NCMLParser& p) const
  {
    const VariableElement* pMyParent = getContainingVariableElement(p);
    VALID_PTR(pMyParent);
    return pMyParent->type();
  }

  const VariableElement*
  ValuesElement::getContainingVariableElement(NCMLParser& p) const
  {
    const VariableElement* ret = 0;

    // Get the parse stack for p and walk up it!
    NCMLParser::ElementStackConstIterator it;
    NCMLParser::ElementStackConstIterator endIt = p.getElementStackEnd();
    for (it = p.getElementStackBegin(); it != endIt; ++it)
    {
      const NCMLElement* pElt = *it;
      const VariableElement* pVarElt = dynamic_cast<const VariableElement*>(pElt);
      if (pVarElt)
        {
          ret = pVarElt;
          break;
        }
    }
    return ret;

  }

}
